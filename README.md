# AIS 메시지 수신 및 파싱 서버
## 아키텍처
![Image](https://github.com/user-attachments/assets/f3e20a1e-b6ff-479f-9832-ddc298d5b06f)

#### 흐름
1. 애플리케이션 Main을 통해 진입 후 WebSocket 서버 및 DB 핸들러 초기화
2. TcpReciver를 통해  외부에서 데이터 수신
3. Decoder(Type5의 메시지), Decoder(Type1의 메시지)을 통해 메시지를 파싱한다.
4. 파싱 된 메시지를 유틸을 호출하여 메시지를 가공한다.
5. DB 계층에서 가공된 메시지를 저장한다.
6. Transmit 클래스로 메시지를 전달하고 WebSocket을 통해 클라이언트로 전송된다.
7. Type 5 메시지의 경우 ExternalApi(해양수산부 API) 클래스와 상호작용하여 선박의 제원정보를 조회한다.

#### 설계 방향성
1. 각 기능을 수신,파싱,가공처리,DB저장 으로 분리하여 명확화
3. 데이터 흐름이 단순하고 일방향적이기 때문에 레이어 아키텍처로 구성

#### 단점
1. 메시지가 초당 수만건 이상 수신될 때 레이어 마다 흐름을 거치면 병목이 발생할 가능성이 있음
2. 조건적으로 분기하는 로직이 많아지면 코드가 복잡해짐
  
## 리팩터링

단일 책임 원칙 준수 : 한 클래스가 담당하고 있던 여러 기능들을 분리
  
가설 :   
기존에 사용하던 코드에는 많은 로직이 없었지만, 점점 요구사항과 문자열 가공처리 이슈가 생기다 보니 한가지 클래스가 너무 많은 일을 하고 있었다. 
이에따라 코드가 스파게티 처럼 얽혀 있고 한번에 이해하기 힘들어 유지보수에 어려움이 있다. 
수신, 파싱, 가공, 저장, 전송 기능을 유틸리티 클래스로 분류하고 메시지 타입별로 분기조건을 설정하면 코드가 이해하기 쉽게 재구성될 것이다.  



// 무엇을 바꿨는지, 어떻게 바꿨는지, 왜 바꿨는지, 개선된 점은 무엇인지, 리팩터링 이전/이후 코드 비교

하드 코딩 제거 : 인터페이스로 추상화 하거나 Mock 개체 주입 가능하게 설계 변경

Async 예외 처리 : 예외가 발생했을 때 시스템은 계속 동작하되 클라이언트에게 에러 발생 메시지 전송
