# AIS 메시지 수신 및 파싱 서버
## 아키텍처
![Image](https://github.com/user-attachments/assets/f3e20a1e-b6ff-479f-9832-ddc298d5b06f)

#### 흐름
1. 애플리케이션 Main을 통해 진입 후 WebSocket 서버 및 DB 핸들러 초기화
2. TcpReciver를 통해  외부에서 데이터 수신
3. Decoder(Type5의 메시지), Decoder(Type1의 메시지)을 통해 메시지를 파싱한다.
4. 파싱 된 메시지를 유틸을 호출하여 메시지를 가공한다.
5. DB 계층에서 가공된 메시지를 저장한다.
6. Transmit 클래스로 메시지를 전달하고 WebSocket을 통해 클라이언트로 전송된다.
7. Type 5 메시지의 경우 ExternalApi(해양수산부 API) 클래스와 상호작용하여 선박의 제원정보를 조회한다.

#### 설계 방향성
1. 각 기능을 수신,파싱,가공처리,DB저장 으로 분리하여 명확화
3. 데이터 흐름이 단순하고 일방향적이기 때문에 레이어 아키텍처로 구성

#### 단점
1. 메시지가 초당 수만건 이상 수신될 때 레이어 마다 흐름을 거치면 병목이 발생할 가능성이 있음
2. 조건적으로 분기하는 로직이 많아지면 코드가 복잡해짐
  
## 리팩터링

단일 책임 원칙 준수 : 한 클래스가 담당하고 있던 여러 기능들을 분리
  
가설 :   
- 기존에 사용하던 코드에는 많은 로직이 없었지만, 점점 요구사항과 문자열 가공처리 이슈가 생기다 보니 한가지 클래스가 너무 많은 일을 하고 있었다. 
- 코드가 스파게티 처럼 얽혀 있고 한번에 이해하기 힘들어 유지보수에 어려움이 있다. 
- 수신, 파싱, 가공, 저장, 전송 기능을 유틸리티 클래스로 분류하고 메시지 타입별로 분기조건을 설정하면 코드가 이해하기 쉽게 재구성될 것이다.  

조건 :  
- 기존에 동작하던 기능은 수정하지 않는다.  
- 기존 코드를 더 쉽고 간결하게 수정한다.  

변경점 :  
1. 기존에 Type 1 메시지와 Type 5 메시지가 한 클래스 내에서 분기하여 처리하는 것을 Decoder(Type 5), Decoder1(Type 1) 클래스로 분리
1. 위.경도, Speed, 미래 위치를 계산하는 코드를 CaculateUtil 클래스로 분류
2. 파싱된 메시지를 가공처리 하기 위한 코드를 MessageBuilderUtil, RemoveLetterUtil 클래스로 분류 

결과 :  
1. 기존 380 줄 길이의 코드를 100줄 이하의 코드로 줄였다. 이를 통해 코드의 가독성이 증가했고 복잡성이 감소했다.  
2. 중복코드, 죽은코드, 불필요한 println() 삭제 코드줄 삭제
3. WebSocket 중복 접속 버그 수정

// 무엇을 바꿨는지, 어떻게 바꿨는지, 왜 바꿨는지, 개선된 점은 무엇인지, 리팩터링 이전/이후 코드 비교

하드 코딩 제거 : 인터페이스로 추상화 하거나 Mock 개체 주입 가능하게 설계 변경

Async 예외 처리 : 예외가 발생했을 때 시스템은 계속 동작하되 클라이언트에게 에러 발생 메시지 전송
