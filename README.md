# AIS 메시지 수신 및 파싱 서버
## 아키텍처
![Image](https://github.com/user-attachments/assets/f3e20a1e-b6ff-479f-9832-ddc298d5b06f)

#### 흐름
1. 애플리케이션 Main을 통해 진입 후 WebSocket 서버 및 DB 핸들러 초기화
2. TcpReciver를 통해  외부에서 데이터 수신
3. Decoder(Type5의 메시지), Decoder(Type1의 메시지)을 통해 메시지를 파싱한다.
4. 파싱 된 메시지를 유틸을 호출하여 메시지를 가공한다.
5. DB 계층에서 가공된 메시지를 저장한다.
6. Transmit 클래스로 메시지를 전달하고 WebSocket을 통해 클라이언트로 전송된다.
7. Type 5 메시지의 경우 ExternalApi(해양수산부 API) 클래스와 상호작용하여 선박의 제원정보를 조회한다.

#### 설계 방향성
1. 각 기능을 수신,파싱,가공처리,DB저장 으로 분리하여 명확화
3. 데이터 흐름이 단순하고 일방향적이기 때문에 레이어 아키텍처로 구성

#### 단점
1. 메시지가 초당 수만건 이상 수신될 때 레이어 마다 흐름을 거치면 병목이 발생할 가능성이 있음
2. 조건적으로 분기하는 로직이 많아지면 코드가 복잡해짐
  
## 리팩터링

단일 책임 원칙 준수 : 한 클래스가 담당하고 있던 여러 기능들을 분리
  
가설 :   
- 기존 코드에는 많은 로직이 없었지만, 점점 요구사항과 문자열 가공처리 이슈가 생기다 보니 단일 클래스가 지나치게 많은 책임을 갖고 있었다. 
- 코드가 스파게티 처럼 얽히게 되어 이해하기 어렵고 유지보수가 힘든 구조가 되었다. 
- 수신, 파싱, 가공, 저장, 전송 기능을 유틸리티 클래스, 메시지 타입별 클래스를 분리하면 코드가 명확해져 이해하기 쉬운 코드로 재구성 될 것이다.  

조건 :  
- 기존에 정상 동작하던 기능은 수정하지 않는다.  
- 기존 코드를 더 간결하고 직관적으로 이해할 수 있도록 수정한다.  

변경점 :  
- 단일책임 원칙 준수 : 기존 클래스에 Type 1, 5 메시지를 동시에 처리하던 분기 로직을 Decoder1(Type 1), Decoder(Type 5) 클래스로 분리
- 유틸화 및 기능 분리 : 위/경도, 속도(Sog),계산, 메시지 가공 처리 등 반복되는 로직을 CaculateUtil, MessageBuilderUtil로 분리
  
결과 :  
1. 기존 380 줄 길이의 코드를 100줄 이하의 코드로 줄였다. 이를 통해 코드의 가독성 및 유지보수성 향상.  
2. 중복코드 및 불필요한 출력 코드 제거
3. WebSocket 중복 접속으로 인한 버그 수정  

하드 코딩 제거 : 인터페이스로 추상화 하거나 Mock 개체 주입 가능하게 설계 변경

Async 예외 처리 : 예외가 발생했을 때 시스템은 계속 동작하되 클라이언트에게 에러 발생 메시지 전송
